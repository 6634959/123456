<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>é‡å­çº§å®‰å…¨å“ˆå¸Œè½¬æ¢å™¨ v2.0</title>
    <style>
        /* æ ·å¼ä¿æŒä¸å˜ */
        :root { --neon-green: #0f0; --cyber-red: #ff003c; }
        body { font-family: 'Consolas', monospace; background: radial-gradient(circle, #001 0%, #000 100%); color: var(--neon-green); max-width: 800px; margin: 2rem auto; padding: 20px; position: relative; overflow-x: hidden; }
        .container { border: 3px solid var(--neon-green); padding: 20px; border-radius: 5px; background: rgba(0, 255, 0, 0.05); box-shadow: 0 0 20px rgba(0, 255, 0, 0.2); position: relative; z-index: 1; }
        input, button { background: rgba(0, 0, 0, 0.8); color: var(--neon-green); border: 1px solid var(--neon-green); padding: 12px; margin: 8px; transition: all 0.3s; font-size: 16px; }
        button:hover { background: rgba(0, 255, 0, 0.1); box-shadow: 0 0 10px var(--neon-green); cursor: pointer; }
        #status { color: var(--cyber-red); margin-top: 15px; min-height: 24px; font-family: 'Courier New', monospace; }
        .cyber-loader { display: none; border: 2px solid var(--neon-green); padding: 10px; margin: 10px 0; position: relative; }
        .progress-bar { height: 3px; background: var(--neon-green); width: 0; transition: width 0.3s; }
        .glitch-effect { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; opacity: 0.1; background: repeating-linear-gradient(45deg, transparent, transparent 2px, var(--neon-green) 2px, var(--neon-green) 4px); animation: glitch 2s infinite; }
        @keyframes glitch { 0% { transform: translate(0); } 20% { transform: translate(-2px, 2px); } 40% { transform: translate(-2px, -2px); } 60% { transform: translate(2px, 2px); } 80% { transform: translate(2px, -2px); } 100% { transform: translate(0); } }
    </style>
</head>
<body>
    <div class="glitch-effect"></div>
    <div class="container">
        <h2>é‡å­åŠ å¯†å“ˆå¸Œç”Ÿæˆå™¨ v2.0</h2>
        <input type="number" id="inputNumber" placeholder="è¾“å…¥é‡å­çº§æ•°å­—" min="1" step="1">
        <button onclick="startHashing()" id="hashButton">å¯åŠ¨é‡å­å¼•æ“</button>
        <button onclick="resetInput()" id="resetButton" style="display: none;">å†æ¬¡åŠ å¯†</button>
        <div class="cyber-loader" id="loader">
            <div class="progress-bar"></div>
        </div>
        <div id="status">[ç³»ç»ŸçŠ¶æ€ï¼šå¾…æœºæ¨¡å¼]</div>
        <div id="output"></div>
    </div>
<script>
    // å¢å¼ºå‹å®‰å…¨é…ç½®
    const QUANTUM_CRYPTO = Object.freeze({
        iterations: 2_500_000,       // åŠ¨æ€è¿­ä»£æ¬¡æ•°
        baseSaltSize: 512,           // åŸºç¡€ç›å€¼é•¿åº¦
        entropyPoolSize: 1024,       // ç†µæ± å®¹é‡
        thermalProtection: true,     // é˜²çƒ­æ‰©æ•£ä¿æŠ¤
        quantumResistant: true,      // åé‡å­å®‰å…¨ç®—æ³•
        getDynamicIterations() {
            // åŸºäºæ—¶é—´åŠ¨æ€è°ƒæ•´è¿­ä»£æ¬¡æ•°
            const hour = new Date().getHours();
            return this.iterations + (hour * 50_000);
        }
    });

    class QuantumSecurityEngine {
        static #worker = null;
        static #instance = null;
        
        constructor() {
            if (!QuantumSecurityEngine.#worker) {
                QuantumSecurityEngine.#worker = this.#initWorker();
            }
            this.worker = QuantumSecurityEngine.#worker;
            this.jobId = 0;
            this.pending = new Map();
            this.entropyPool = new Uint32Array(QUANTUM_CRYPTO.entropyPoolSize);

            // ç»‘å®š Worker æ¶ˆæ¯å¤„ç†
            this.worker.onmessage = (e) => {
                const { id, hash, error } = e.data;
                const { resolve, reject } = this.pending.get(id) || {};
                if (error) {
                    reject(new Error(error));
                } else {
                    resolve(hash);
                }
                this.pending.delete(id);
            };
        }

        #initWorker() {
            const workerCode = `
                const encoder = new TextEncoder();
                const decoder = new TextDecoder("latin1");

                async function processData(number, entropy) {
                    try {
                        // ç”Ÿæˆç›å’Œåˆå§‹åŒ–å‘é‡
                        const [salt, iv] = await Promise.all([
                            crypto.getRandomValues(new Uint8Array(64)),
                            crypto.getRandomValues(new Uint8Array(12))
                        ]);

                        // æ´¾ç”Ÿå¯†é’¥
                        const baseKey = await crypto.subtle.importKey(
                            "raw",
                            encoder.encode(number.toString()),
                            "PBKDF2",
                            false,
                            ["deriveKey"]
                        );

                        const derivedKey = await crypto.subtle.deriveKey(
                            {
                                name: "PBKDF2",
                                salt,
                                iterations: 2000000,
                                hash: "SHA-512"
                            },
                            baseKey,
                            { name: "HMAC", hash: "SHA-512" },
                            true,
                            ["sign"]
                        );

                        // ç”Ÿæˆæœ€ç»ˆå“ˆå¸Œ
                        const hashBuffer = await crypto.subtle.digest("SHA-512", salt);
                        const hash = btoa(String.fromCharCode(...new Uint8Array(hashBuffer)));
                        return hash;
                    } catch (error) {
                        throw error;
                    }
                }

                self.onmessage = async (e) => {
                    const { id, number, entropy } = e.data;
                    try {
                        const hash = await processData(number, entropy);
                        self.postMessage({ id, hash });
                    } catch (error) {
                        self.postMessage({ id, error: error.message });
                    }
                };
            `;
            return new Worker(URL.createObjectURL(new Blob([workerCode])));
        }

        async generateHash(number) {
            return new Promise((resolve, reject) => {
                const id = ++this.jobId;
                this.pending.set(id, { resolve, reject });

                // æ›´æ–°ç†µæ± 
                crypto.getRandomValues(this.entropyPool);

                this.worker.postMessage({
                    id,
                    number,
                    entropy: this.entropyPool
                }, [this.entropyPool.buffer]);
            });
        }
    }

    // åˆå§‹åŒ–é‡å­å¼•æ“
    const Q_ENGINE = new QuantumSecurityEngine();
    let isProcessing = false;

    async function startHashing() {
        if (isProcessing) {
            showAlert("âš ï¸ é‡å­å¼•æ“æ­£åœ¨è¿è¡Œä¸­");
            return;
        }
        
        const input = document.getElementById("inputNumber").value;
        if (!input || isNaN(input)) {
            showAlert("âŒ è¾“å…¥å¿…é¡»ä¸ºæœ‰æ•ˆæ•°å­—");
            return;
        }

        try {
            isProcessing = true;
            updateUIState(true);
            
            const hash = await Q_ENGINE.generateHash(input);
            displayHashResult(hash);
        } catch (error) {
            showAlert(`âš ï¸ é‡å­å¼‚å¸¸: ${error.message}`);
        } finally {
            isProcessing = false;
            updateUIState(false);
            document.getElementById("resetButton").style.display = "inline-block";
        }
    }

    // ä¿®æ”¹â€œå†æ¬¡åŠ å¯†â€é€»è¾‘ä¸ºåˆ·æ–°é¡µé¢
    function resetInput() {
        location.reload(); // åˆ·æ–°é¡µé¢
    }

        // UI å¢å¼ºåŠŸèƒ½
    function updateUIState(isProcessing) {
        const loader = document.getElementById("loader");
        const button = document.getElementById("hashButton");
        const progress = document.querySelector(".progress-bar");
        
        loader.style.display = isProcessing ? "block" : "none";
        button.disabled = isProcessing;
        progress.style.width = isProcessing ? "100%" : "0";
        document.getElementById("status").textContent = isProcessing 
            ? `[é‡å­åŠ å¯†ä¸­... ${QUANTUM_CRYPTO.getDynamicIterations().toLocaleString()}æ¬¡è¿­ä»£]`
            : "[ç³»ç»ŸçŠ¶æ€ï¼šå°±ç»ª]";
    }

    function displayHashResult(hash) {
        const output = document.getElementById("output");
        output.innerHTML = `
            <div class="cyber-result">
                <h3>é‡å­æŒ‡çº¹ï¼š</h3>
                <div class="hash-output">${formatHash(hash)}</div>
                <div class="security-level">ğŸ” å®‰å…¨ç­‰çº§ï¼šL5-é‡å­æŠ—æ€§</div>
            </div>
        `;
    }

    function formatHash(hash) {
        return hash.match(/.{1,64}/g).join('<br>');
    }

    function showAlert(message) {
        const status = document.getElementById("status");
        status.innerHTML = message;
        status.style.color = "#ff003c";
        setTimeout(() => status.style.color = "#00ff00", 2000);
    }
</script>
</body>
</html>
